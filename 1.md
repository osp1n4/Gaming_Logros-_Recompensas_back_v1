# Plan de implementación del frontend por fases

Este plan sigue el orden de las pantallas diseñadas en `frontend/stitch_registration_and_login_screen` y describe los pasos para construir el frontend conectándolo con los microservicios (`player-service`, `achievement-service`, `reward-service`) del backend. Cada fase incluye prácticas recomendadas de arquitectura, pruebas, seguridad y accesibilidad.

## Lineamientos transversales
- **Stack y arquitectura:** reutilizar un solo proyecto (ej. React + Vite o Next.js) con routing declarativo y estado global (Redux Toolkit, Zustand o Context + React Query) para cachear datos provenientes de los servicios. Separar layout, componentes atómicos y hooks por dominio.
- **Tipado y contratos:** generar tipos a partir de los DTO expuestos por los servicios (OpenAPI, Swagger o Zod) y versionar los contratos compartidos en `shared/` para evitar desalineaciones.
- **Seguridad:** manejar JWT con `httpOnly` cookies cuando sea posible, refrescar tokens, sanitizar entrada/salida y aplicar `Content Security Policy` estricta.
- **UX y accesibilidad:** respetar la jerarquía tipográfica, usar componentes accesibles (labels, `aria-*`, navegación con teclado) y soportar tema oscuro/claro.
- **Pruebas:** por fase incluir pruebas unitarias de componentes (Testing Library), pruebas de hooks y contratos (msw) y smoke tests e2e (Playwright/Cypress) alineados con los flujos de backend ya cubiertos por `e2e-tests/`.
- **Observabilidad:** instrumentar eventos clave con OpenTelemetry/Analytics para rastrear conversiones de registro, claim de recompensas, progreso y notificaciones.

## Fase 1 · Registro e inicio de sesión (`1 registration_and_login_screen`)
1. **Bootstrap de autenticación:** crear vistas `/auth/register` y `/auth/login` reutilizando el diseño. Implementar formularios controlados con validaciones sincrónicas (Yup/Zod) y estados de error accesibles.
2. **Integración backend:**
   - `player-service`: `POST /players` para registro, `POST /auth/login` para login y `GET /players/me` para hidratar el contexto del usuario.
   - Guardar tokens en cookies seguras y refrescar en segundo plano.
3. **UX:** animar botones (neon glow), añadir opción de login social si el backend expone OAuth (dejar placeholders desacoplados).
4. **Pruebas:** mockear respuestas del `player-service`, validar estados de carga/errores y flujos de redirección tras login.

## Fase 2 · Panel del jugador (`2 player_dashboard_overview`)
1. **Layout maestro:** implementar `DashboardLayout` con sidebar, topbar y slots para contenido dinámico. Conectar rutas protegidas mediante un guard que valide el contexto del jugador.
2. **Widgets de estadísticas:** consumir agregados desde:
   - `player-service`: saldo de monedas, nivel, XP.
   - `achievement-service`: conteo de logros completados.
   - `reward-service`: recompensas recientes.
   Cachear respuestas con React Query y mostrar estados de skeleton.
3. **Eventos rápidos:** mapear acciones a endpoints (ej. `POST /quests/{id}/complete` en `player-service`). Deshabilitar botones según permisos provenientes del backend.
4. **Pruebas e2e:** validar que la navegación entre tabs respeta el rol del usuario y que los datos renderizados coinciden con fixtures de los servicios.

## Fase 3 · Cuadrícula de logros (`3. achievements_progress_grid`)
1. **Vista de logros:** implementar filtros (All/Unlocked/Locked/Timed) y búsquedas client-side con debouncing. Reutilizar componentes card con variantes (desbloqueado, en progreso, limitado, bloqueado).
2. **Integración:**
   - `achievement-service`: `GET /achievements`, `GET /achievements/:id/progress`, `POST /achievements/:id/claim`.
   - Sincronizar progreso global (barra «Grandmaster Journey») con agregados devueltos por el backend.
3. **Gestión de estado:** mantener progreso en cache y usar websockets/RabbitMQ (si está expuesto) para actualizaciones en tiempo real.
4. **Pruebas:** cubrir filtros, paginación y sincronización en tiempo real usando msw + WebSocket mocks.

## Fase 4 · Recompensas y balance (`4. player_rewards_and_balance`)
1. **Tabs Assigned/Claimed/My Balance:** estructurar la vista con componentes reutilizables y estados de loading.
2. **Integración con `reward-service`:**
   - `GET /rewards/assigned`, `POST /rewards/:id/claim`, `GET /rewards/history`.
   - `GET /balance` para monedas y XP acumulados (puede venir de `player-service`).
3. **Inventario:** sincronizar la galería con el backend, permitiendo paginación o lazy loading.
4. **Pruebas:** validar idempotencia del botón «Claim Now» (bloquear doble click) y coherencia de los totales al recibir eventos de actualización.

## Fase 5 · Ranking global (`5. global_leaderboard_ranking`)
1. **Podio y tablas:** construir componentes `PodiumCard` y `LeaderboardTable` con soporte para ordenamiento (Coins/XP/Achievements) y paginación.
2. **Integración:**
   - `player-service` o `achievement-service` según API de rankings (`GET /leaderboard?metric=coins`).
   - Suscribirse a eventos de actualización (WebSocket/RabbitMQ) para refrescar posición sin recargar.
3. **Personal rank banner:** obtener la posición personal desde `GET /leaderboard/me`.
4. **Pruebas:** comparar datos con snapshots del backend y validar accesibilidad de tablas (roles, focus, navegación con teclado).

## Fase 6 · Notificaciones y modal de logros (`6. notifications_and_achievement_modal`)
1. **Sistema de toasts:** crear un `NotificationCenter` que consuma eventos (logros, recompensas, errores de sincronización) desde un canal en tiempo real (RabbitMQ → WebSocket). Persistir notificaciones en IndexedDB/localStorage para resiliencia offline.
2. **Modal de logros:** construir componente reutilizable que reciba el ID del logro, consulte `achievement-service` y muestre progreso, recompensas y acciones (`POST /achievements/:id/track`).
3. **Estados de red:** manejar reintentos exponenciales para errores y mostrar banners de conectividad.
4. **Pruebas:** simular bursts de notificaciones, validar focus-trap del modal y cobertura de accesibilidad (ARIA `role=dialog`).

## Fase 7 · Navegación y estados UI (`7. navigation_and_ui_states`)
1. **Shell global:** refinar el header, selector de idioma y menús contextuales. Centralizar la definición de rutas protegidas, breadcrumbs y permisos.
2. **Estados de carga vacíos:** implementar skeletons y empty-states compartidos que sigan el diseño (sincronización, call-to-action «Browse Quests»).
3. **Internacionalización:** integrar i18n (lingui, i18next) con namespaces por dominio. Conectar con el backend solo si existen strings dinámicos; de lo contrario versionar locales en el frontend.
4. **Monitoreo y performance:** medir CLS/LCP para vistas con muchos gráficos, optimizar imágenes (avatars) con cargas diferidas y aplicar `prefetch` de datos al cambiar de tab.
5. **Pruebas finales:** ejecutar regresiones cruzadas (navegación completa autenticada, fallback offline, cambios de idioma) y alinear con `e2e-tests/complete-flow.e2e.spec.ts`.

## Cierre y despliegue
- Automatizar la pipeline (CI) para correr lint, unit tests, coverage y e2e. Integrar con el `docker-compose` del backend para revisar contratos antes de publicar.
- Versionar cada fase (tags `frontend-phase-1`, ...) y coordinar releases con el equipo backend para garantizar compatibilidad de endpoints.
